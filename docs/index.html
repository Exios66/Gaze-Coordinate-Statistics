<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaze Data Analysis</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hull.js/1.0.2/hull.js"></script>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --section-bg: #f9f9f9;
            --border-color: #dddddd;
            --primary-color: #4CAF50;
            --hover-color: #45a049;
            --chart-bg: #ffffff;
            --chart-text: #333333;
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --section-bg: #2d2d2d;
            --border-color: #404040;
            --primary-color: #2ecc71;
            --hover-color: #27ae60;
            --chart-bg: #2d2d2d;
            --chart-text: #e0e0e0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: Arial, sans-serif; 
            margin: 20px; 
            line-height: 1.6;
        }
        .section { 
            margin: 20px 0; 
            padding: 15px; 
            border: 1px solid var(--border-color); 
            border-radius: 5px;
            background-color: var(--section-bg);
        }
        .chart { 
            width: 100%; 
            height: 400px; 
            margin: 15px 0;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--chart-bg);
        }
        input, button { 
            margin: 10px 5px 10px 0; 
            padding: 8px 12px;
        }
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: var(--hover-color);
        }
        #logger {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: var(--section-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
        }
        .log-info { color: var(--text-color); }
        .log-success { color: var(--primary-color); }
        .log-warning { color: #ff9800; }
        .log-error { color: #f44336; }
        .loading {
            display: none;
            margin-left: 10px;
            animation: spin 2s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>Gaze Data Analysis Tool
        <button id="themeToggle" style="position: absolute; right: 20px; top: 20px;">ðŸŒ“</button>
    </h1>
    
    <div class="section">
        <h3>Data Input</h3>
        <p>Upload a CSV file with eye-tracking data. The file should contain columns for timestamp, x, and y coordinates.</p>
        <div class="file-input-container">
            <label for="csvFile">Select CSV file:</label>
            <input type="file" id="csvFile" accept=".csv">
        </div>
        <button id="processButton" onclick="processData()">Process Data</button>
        <span id="loading" class="loading">âŸ³</span>
    </div>

    <div id="logger" class="section">
        <div class="log-info">System ready. Upload a CSV file to begin analysis.</div>
    </div>

    <div id="output" class="section" style="display:none;">
        <h3>Analysis Results</h3>
        <div id="resultsContent"></div>
    </div>
    
    <div id="visualizations" class="section" style="display:none;">
        <h3>Visualizations</h3>
        <div id="gazePath" class="chart"></div>
        <div id="velocityChart" class="chart"></div>
        <div id="fixationMap" class="chart"></div>
        <div id="heatmap" class="chart"></div>
    </div>

    <script>
        // Global variables
        let logger;

        // Add theme management at the top of the script
        const themeManager = {
            currentTheme: localStorage.getItem('theme') || 'light',
            
            init() {
                document.documentElement.setAttribute('data-theme', this.currentTheme);
                this.updateChartThemes();
            },

            toggle() {
                this.currentTheme = this.currentTheme === 'light' ? 'dark' : 'light';
                document.documentElement.setAttribute('data-theme', this.currentTheme);
                localStorage.setItem('theme', this.currentTheme);
                this.updateChartThemes();
                logger.info(`Switched to ${this.currentTheme} theme`);
            },

            updateChartThemes() {
                const layout = {
                    paper_bgcolor: getComputedStyle(document.documentElement)
                        .getPropertyValue('--chart-bg').trim(),
                    plot_bgcolor: getComputedStyle(document.documentElement)
                        .getPropertyValue('--chart-bg').trim(),
                    font: {
                        color: getComputedStyle(document.documentElement)
                            .getPropertyValue('--chart-text').trim()
                    }
                };

                ['gazePath', 'velocityChart', 'fixationMap'].forEach(chartId => {
                    Plotly.relayout(chartId, layout);
                });
            }
        };

        // Initialize theme on load
        document.addEventListener('DOMContentLoaded', function() {
            themeManager.init();
            document.getElementById('themeToggle').addEventListener('click', () => themeManager.toggle());
            logger = new Logger('logger');
            logger.info('Gaze Data Analysis Tool initialized');
            logger.info('Please upload a CSV file to begin');
        });

        // Logging utility class
        class Logger {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                if (!this.element) {
                    console.error('Logger element not found:', elementId);
                    return;
                }
            }

            log(message, level = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-${level}`;
                logEntry.innerHTML = `[${timestamp}] ${message}`;
                this.element.appendChild(logEntry);
                this.element.scrollTop = this.element.scrollHeight;
                console.log(`[${level.toUpperCase()}] ${message}`);
            }

            info(message) { this.log(message, 'info'); }
            success(message) { this.log(message, 'success'); }
            warning(message) { this.log(message, 'warning'); }
            error(message) { this.log(message, 'error'); }
            
            clear() {
                this.element.innerHTML = '';
            }
        }

        async function processData() {
            try {
                // Show loading indicator
                document.getElementById('loading').style.display = 'inline-block';
                document.getElementById('processButton').disabled = true;
                
                logger.info('Starting data processing...');
                
                const file = document.getElementById('csvFile').files[0];
                if (!file) {
                    logger.error('No file selected. Please choose a CSV file.');
                    return;
                }
                
                logger.info(`Processing file: ${file.name} (${formatFileSize(file.size)})`);
                
                // Read the file content
                const text = await file.text();
                logger.info(`File loaded successfully. Parsing CSV data...`);
                
                // Parse CSV
                const data = parseCSV(text);
                logger.info(`CSV parsed successfully. Found ${data.length} data points.`);
                
                if (data.length === 0) {
                    logger.error('No data found in CSV file or parsing failed.');
                    return;
                }

                // Check for required columns
                const requiredColumns = ['timestamp', 'x', 'y'];
                const missingColumns = requiredColumns.filter(col => !(col in data[0]));
                
                if (missingColumns.length > 0) {
                    logger.error(`Missing required columns: ${missingColumns.join(', ')}`);
                    logger.info(`Available columns: ${Object.keys(data[0]).join(', ')}`);
                    return;
                }
                
                // Preprocessing
                logger.info('Preprocessing data...');
                let df = preprocessData(data);
                logger.success(`Preprocessing complete. Data normalized and derivatives calculated.`);
                
                // Basic Metrics
                logger.info('Calculating basic statistics...');
                const basicStats = calculateBasicStats(df);
                logger.success('Basic statistics calculated successfully.');
                
                // Fixation/Saccade Detection
                logger.info('Detecting fixations and saccades...');
                const { fixations, saccades } = detectFixationsSaccades(df);
                logger.success(`Detection complete. Found ${fixations.length} fixations and ${saccades.length} saccades.`);
                
                // Advanced Metrics
                logger.info('Calculating advanced metrics...');
                const advancedMetrics = calculateAdvancedMetrics(df, fixations, basicStats);
                logger.success('Advanced metrics calculated successfully.');
                
                // Display Results
                logger.info('Displaying results...');
                displayResults(basicStats, fixations, saccades, advancedMetrics);
                
                // Create Visualizations
                logger.info('Generating visualizations...');
                createVisualizations(df, fixations);
                logger.success('Analysis complete!');
                
                // Show output and visualization sections
                document.getElementById('output').style.display = 'block';
                document.getElementById('visualizations').style.display = 'block';
            } catch (error) {
                logger.error(`Error during data processing: ${error.message}`);
                console.error('Processing error:', error);
            } finally {
                // Hide loading indicator
                document.getElementById('loading').style.display = 'none';
                document.getElementById('processButton').disabled = false;
            }
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }

        function parseCSV(text) {
            const nanSafeParse = (value) => {
                const num = parseFloat(value);
                return isNaN(num) ? null : num;
            };

            const rows = text.split('\n')
                .map(row => row.trim())
                .filter(row => row.length > 0);

            if (rows.length < 2) {
                logger.error('CSV requires header row + at least 1 data row');
                return [];
            }

            // Auto-detect column types
            const headers = rows[0].split(',').map(h => h.trim().toLowerCase());
            const sampleData = rows[1].split(',');
            
            const columnTypes = headers.map((header, i) => {
                const value = sampleData[i];
                return {
                    name: header,
                    type: header.includes('time') ? 'timestamp' :
                        !isNaN(parseFloat(value)) ? 'number' : 'string'
                };
            });

            logger.info(`Detected columns: ${JSON.stringify(columnTypes)}`);

            // Enhanced parsing with error recovery
            const data = [];
            const errors = [];
            
            for (let i = 1; i < rows.length; i++) {
                const values = rows[i].split(',');
                const rowObj = {};
                let isValid = true;

                columnTypes.forEach((col, j) => {
                    let value = values[j]?.trim() || '';
                    
                    switch(col.type) {
                        case 'timestamp':
                            const ts = Date.parse(value);
                            rowObj[col.name] = isNaN(ts) ? null : ts;
                            break;
                        case 'number':
                            rowObj[col.name] = nanSafeParse(value);
                            if (rowObj[col.name] === null) {
                                errors.push(`Row ${i+1}: Invalid number in ${col.name}`);
                                isValid = false;
                            }
                            break;
                        default:
                            rowObj[col.name] = value;
                    }
                });

                if (isValid) data.push(rowObj);
            }

            if (errors.length > 0) {
                logger.warning(`${errors.length} parsing errors detected`);
                errors.forEach(e => logger.warning(e));
            }

            return data;
        }

        function preprocessData(data) {
            // Normalize coordinates to [0,1] range
            const xValues = data.map(d => d.x).filter(v => v !== null);
            const yValues = data.map(d => d.y).filter(v => v !== null);
            
            const xRange = [Math.min(...xValues), Math.max(...xValues)];
            const yRange = [Math.min(...yValues), Math.max(...yValues)];
            
            return data.map(d => ({
                ...d,
                x_norm: (d.x - xRange[0]) / (xRange[1] - xRange[0]),
                y_norm: (d.y - yRange[0]) / (yRange[1] - yRange[0]),
                // Add derived measures
                dx: null,
                dy: null,
                velocity: null,
                acceleration: null
            }));
        }

        function calculateBasicStats(df) {
            try {
                const x = df.map(d => d.x);
                const y = df.map(d => d.y);
                const velocities = df.map(d => d.velocity).filter(v => !isNaN(v) && isFinite(v));
                const distances = df.map(d => d.distance).filter(d => !isNaN(d) && isFinite(d));
                
                const duration = (df[df.length-1].timestamp - df[0].timestamp) / 1000;
                const totalDistance = distances.reduce((sum, d) => sum + d, 0);
                
                const stats = {
                    duration_sec: duration,
                    total_distance: totalDistance,
                    average_distance_per_sec: totalDistance / duration,
                    velocity_mean: mean(velocities),
                    velocity_median: median(velocities),
                    velocity_std: std(velocities),
                    velocity_max: Math.max(...velocities),
                    x_mean: mean(x),
                    y_mean: mean(y),
                    x_std: std(x),
                    y_std: std(y),
                    total_points: df.length,
                    sampling_rate: df.length / duration
                };
                
                // Log key statistics
                logger.info(`Duration: ${stats.duration_sec.toFixed(2)} seconds`);
                logger.info(`Total distance: ${stats.total_distance.toFixed(2)} pixels`);
                logger.info(`Mean velocity: ${stats.velocity_mean.toFixed(2)} pixels/sec`);
                logger.info(`Sampling rate: ${stats.sampling_rate.toFixed(2)} Hz`);
                
                return stats;
            } catch (error) {
                logger.error(`Error calculating basic statistics: ${error.message}`);
                return {
                    duration_sec: 0,
                    total_distance: 0,
                    velocity_mean: 0,
                    velocity_max: 0,
                    x_mean: 0,
                    y_mean: 0,
                    x_std: 0,
                    y_std: 0,
                    total_points: 0,
                    sampling_rate: 0
                };
            }
        }

        function detectFixationsSaccades(df) {
            const config = {
                velocityThreshold: 100, // pixels/sec
                minFixationDuration: 60, // ms
                maxMissingData: 0.2, // 20% allowed missing
                dispersionThreshold: 0.05 // normalized
            };

            // Velocity-based classification
            let inFixation = false;
            let currentFixation = [];
            const fixations = [];

            df.forEach((point, i) => {
                // Data quality check
                const missingValues = ['x', 'y', 'timestamp']
                    .filter(f => point[f] === null).length;
                    
                if (missingValues / 3 > config.maxMissingData) {
                    logger.warning(`Skipping point ${i} due to missing data`);
                    return;
                }

                if (point.velocity < config.velocityThreshold) {
                    if (!inFixation) {
                        currentFixation = [point];
                        inFixation = true;
                    } else {
                        currentFixation.push(point);
                    }
                } else {
                    if (inFixation) {
                        const duration = currentFixation[currentFixation.length-1].timestamp -
                                       currentFixation[0].timestamp;
                                   
                        if (duration >= config.minFixationDuration) {
                            fixations.push(analyzeFixation(currentFixation, config));
                        }
                        currentFixation = [];
                        inFixation = false;
                    }
                }
            });

            // Post-process fixations
            return mergeAdjacentFixations(fixations, df);
        }

        function analyzeFixation(points, config) {
            const centroid = {
                x: points.reduce((sum, p) => sum + p.x_norm, 0) / points.length,
                y: points.reduce((sum, p) => sum + p.y_norm, 0) / points.length
            };

            const dispersion = Math.max(
                Math.max(...points.map(p => p.x_norm)) - Math.min(...points.map(p => p.x_norm)),
                Math.max(...points.map(p => p.y_norm)) - Math.min(...points.map(p => p.y_norm))
            );

            return {
                start: points[0].timestamp,
                end: points[points.length-1].timestamp,
                duration: points[points.length-1].timestamp - points[0].timestamp,
                centroid,
                dispersion,
                valid: dispersion <= config.dispersionThreshold,
                points: points.map(p => ({x: p.x, y: p.y}))
            };
        }

        function calculateAdvancedMetrics(df, fixations, stats) {
            try {
                // Path efficiency (straight-line distance / total distance)
                const start = [df[0].x, df[0].y];
                const end = [df[df.length-1].x, df[df.length-1].y];
                const straightLineDistance = Math.hypot(end[0]-start[0], end[1]-start[1]);
                const pathEfficiency = straightLineDistance / stats.total_distance;
                
                logger.info(`Path efficiency: ${pathEfficiency.toFixed(4)} (straight: ${straightLineDistance.toFixed(2)} px)`);
                
                // Convex hull area calculation
                let hullArea = 0;
                let fixationDwellTime = 0;
                let meanFixationDuration = 0;
                
                try {
                    const points = df.map(d => [d.x, d.y]);
                    // Skip convex hull if very few points
                    if (points.length > 3) {
                        const hullPoints = window.hull(points, Infinity);
                        if (hullPoints && hullPoints.length > 2) {
                            hullArea = calculatePolygonArea(hullPoints);
                            logger.info(`Convex hull calculated with ${hullPoints.length} points`);
                        } else {
                            logger.warning('Convex hull calculation produced invalid result');
                        }
                    } else {
                        logger.warning('Too few points for convex hull calculation');
                    }
                } catch (hullError) {
                    logger.error(`Convex hull error: ${hullError.message}`);
                }
                
                // Fixation metrics
                if (fixations.length > 0) {
                    fixationDwellTime = fixations.reduce((sum, f) => sum + f.duration, 0) / 1000; // in seconds
                    meanFixationDuration = fixationDwellTime * 1000 / fixations.length; // in ms
                    
                    logger.info(`Total fixation dwell time: ${fixationDwellTime.toFixed(2)} sec (${(fixationDwellTime/stats.duration_sec*100).toFixed(1)}% of total)`);
                    logger.info(`Mean fixation duration: ${meanFixationDuration.toFixed(2)} ms`);
                }
                
                // Scanpath metrics
                const scanpathLength = stats.total_distance;
                const scanpathDuration = stats.duration_sec;
                const scanpathVelocity = scanpathLength / scanpathDuration;
                
                return {
                    path_efficiency: pathEfficiency,
                    convex_hull_area: hullArea,
                    fixation_count: fixations.length,
                    fixation_frequency: fixations.length / scanpathDuration,
                    fixation_dwell_time: fixationDwellTime,
                    fixation_dwell_time_percent: (fixationDwellTime / scanpathDuration) * 100,
                    mean_fixation_duration: meanFixationDuration,
                    scanpath_length: scanpathLength,
                    scanpath_duration: scanpathDuration,
                    scanpath_velocity: scanpathVelocity
                };
            } catch (error) {
                logger.error(`Error calculating advanced metrics: ${error.message}`);
                return {
                    path_efficiency: 0,
                    convex_hull_area: 0,
                    fixation_count: 0,
                    fixation_frequency: 0,
                    fixation_dwell_time: 0,
                    fixation_dwell_time_percent: 0,
                    mean_fixation_duration: 0,
                    scanpath_length: 0,
                    scanpath_duration: 0,
                    scanpath_velocity: 0
                };
            }
        }

        function displayResults(basic, fixations, saccades, advanced) {
            try {
                let html = `
                    <h4>Basic Statistics</h4>
                    <ul>
                        <li>Duration: ${basic.duration_sec.toFixed(2)} seconds</li>
                        <li>Total points: ${basic.total_points}</li>
                        <li>Sampling rate: ${basic.sampling_rate.toFixed(2)} Hz</li>
                        <li>Total distance: ${basic.total_distance.toFixed(2)} pixels</li>
                        <li>Mean velocity: ${basic.velocity_mean.toFixed(2)} pixels/second</li>
                        <li>Max velocity: ${basic.velocity_max.toFixed(2)} pixels/second</li>
                    </ul>

                    <h4>Fixation & Saccade Analysis</h4>
                    <ul>
                        <li>Fixations detected: ${fixations.length}</li>
                        <li>Mean fixation duration: ${advanced.mean_fixation_duration.toFixed(2)} ms</li>
                        <li>Fixation frequency: ${advanced.fixation_frequency.toFixed(2)} per second</li>
                        <li>Fixation dwell time: ${advanced.fixation_dwell_time.toFixed(2)} seconds (${advanced.fixation_dwell_time_percent.toFixed(1)}% of total)</li>
                        <li>Saccades detected: ${saccades.length}</li>
                        ${saccades.length > 0 ? `<li>Mean saccade amplitude: ${mean(saccades.map(s => s.amplitude)).toFixed(2)} pixels</li>` : ''}
                        ${saccades.length > 0 ? `<li>Mean saccade duration: ${mean(saccades.map(s => s.duration)).toFixed(2)} ms</li>` : ''}
                    </ul>

                    <h4>Advanced Metrics</h4>
                    <ul>
                        <li>Path efficiency: ${advanced.path_efficiency.toFixed(4)}</li>
                        <li>Convex hull area: ${advanced.convex_hull_area.toFixed(2)} square pixels</li>
                        <li>Scanpath length: ${advanced.scanpath_length.toFixed(2)} pixels</li>
                        <li>Scanpath velocity: ${advanced.scanpath_velocity.toFixed(2)} pixels/second</li>
                    </ul>
                `;
                
                document.getElementById('resultsContent').innerHTML = html;
                document.getElementById('output').style.display = 'block';
                
                logger.success('Results displayed successfully');
            } catch (error) {
                logger.error(`Error displaying results: ${error.message}`);
            }
        }

        function createVisualizations(df, fixations) {
            try {
                // Add theme colors to all chart layouts
                const chartLayoutSettings = {
                    paper_bgcolor: getComputedStyle(document.documentElement)
                        .getPropertyValue('--chart-bg').trim(),
                    plot_bgcolor: getComputedStyle(document.documentElement)
                        .getPropertyValue('--chart-bg').trim(),
                    font: {
                        color: getComputedStyle(document.documentElement)
                            .getPropertyValue('--chart-text').trim()
                    }
                };

                // 1. Gaze path visualization
                const pathTrace = {
                    x: df.map(d => d.x),
                    y: df.map(d => d.y),
                    mode: 'lines',
                    line: {
                        color: 'rgba(0, 128, 255, 0.7)',
                        width: 2
                    },
                    name: 'Gaze Path',
                    type: 'scatter'
                };
                
                // Create layout with reversed y-axis (typical for screen coordinates)
                const gazePathLayout = {
                    ...chartLayoutSettings,
                    title: 'Gaze Path',
                    xaxis: { 
                        title: 'X Coordinate',
                        color: getComputedStyle(document.documentElement)
                            .getPropertyValue('--chart-text').trim()
                    },
                    yaxis: { 
                        title: 'Y Coordinate',
                        autorange: 'reversed',
                        color: getComputedStyle(document.documentElement)
                            .getPropertyValue('--chart-text').trim()
                    },
                    hovermode: 'closest',
                    margin: { t: 50, b: 50, l: 50, r: 50 }
                };
                
                Plotly.newPlot('gazePath', [pathTrace], gazePathLayout, { responsive: true });
                logger.info('Gaze path visualization created');
                
                // 2. Velocity profile
                const velocityTrace = {
                    x: df.map((d, i) => (d.timestamp - df[0].timestamp) / 1000), // Convert to seconds from start
                    y: df.map(d => d.velocity),
                    mode: 'lines',
                    line: { color: 'rgba(255, 0, 0, 0.7)' },
                    name: 'Velocity',
                    type: 'scatter'
                };
                
                const velocityLayout = {
                    ...chartLayoutSettings,
                    title: 'Velocity Profile',
                    xaxis: { title: 'Time (seconds)' },
                    yaxis: { title: 'Velocity (pixels/second)' },
                    margin: { t: 50, b: 50, l: 50, r: 50 }
                };
                
                Plotly.newPlot('velocityChart', [velocityTrace], velocityLayout, { responsive: true });
                logger.info('Velocity profile visualization created');
                
                // 3. Fixation map
                if (fixations.length > 0) {
                    // Add detected fixations to gaze path plot
                    const fixationTrace = {
                        x: fixations.map(f => f.x_centroid),
                        y: fixations.map(f => f.y_centroid),
                        mode: 'markers',
                        marker: {
                            size: fixations.map(f => Math.sqrt(f.duration) / 5),
                            color: 'rgba(255, 165, 0, 0.8)',
                            line: { width: 1, color: 'black' }
                        },
                        text: fixations.map((f, i) => `Fixation ${i+1}<br>Duration: ${f.duration.toFixed(0)} ms<br>Dispersion: ${f.dispersion.toFixed(1)} px`),
                        name: 'Fixations',
                        type: 'scatter',
                        hoverinfo: 'text'
                    };
                    
                    const fixationMap = {
                        x: fixations.map(f => f.x_centroid),
                        y: fixations.map(f => f.y_centroid),
                        mode: 'markers+text',
                        marker: {
                            size: fixations.map(f => Math.min(Math.max(f.duration / 30, 10), 40)),
                            color: fixations.map((f, i) => `hsl(${(i * 360 / fixations.length) % 360}, 70%, 50%)`),
                            opacity: 0.7,
                            line: { width: 1, color: 'black' }
                        },
                        text: fixations.map((f, i) => `${i+1}`),
                        textposition: 'middle center',
                        textfont: {
                            size: 10,
                            color: 'white'
                        },
                        name: 'Fixations',
                        type: 'scatter',
                        hoverinfo: 'text',
                        hovertext: fixations.map((f, i) => 
                            `Fixation ${i+1}<br>Duration: ${f.duration.toFixed(0)} ms<br>` + 
                            `Position: (${f.x_centroid.toFixed(1)}, ${f.y_centroid.toFixed(1)})<br>` +
                            `Dispersion: ${f.dispersion.toFixed(1)} px`)
                    };
                    
                    const fixationConnections = {
                        x: fixations.flatMap((f, i) => i > 0 ? [fixations[i-1].x_centroid, f.x_centroid, null] : []),
                        y: fixations.flatMap((f, i) => i > 0 ? [fixations[i-1].y_centroid, f.y_centroid, null] : []),
                        mode: 'lines',
                        line: {
                            color: 'rgba(100, 100, 100, 0.5)',
                            width: 1,
                            dash: 'dot'
                        },
                        name: 'Scan Path',
                        type: 'scatter'
                    };
                    
                    const fixationMapLayout = {
                        ...chartLayoutSettings,
                        title: 'Fixation Map',
                        xaxis: { title: 'X Coordinate' },
                        yaxis: { 
                            title: 'Y Coordinate',
                            autorange: 'reversed',
                            color: getComputedStyle(document.documentElement)
                                .getPropertyValue('--chart-text').trim()
                        },
                        showlegend: false,
                        hovermode: 'closest',
                        margin: { t: 50, b: 50, l: 50, r: 50 }
                    };
                    
                    Plotly.newPlot('fixationMap', [fixationMap, fixationConnections], fixationMapLayout, { responsive: true });
                    logger.info('Fixation map created');
                    
                    // Add fixation trace to gaze path
                    Plotly.addTraces('gazePath', [fixationTrace]);
                } else {
                    document.getElementById('fixationMap').innerHTML = '<div style="text-align:center;padding:20px;">No fixations detected</div>';
                    logger.warning('No fixations to display on fixation map');
                }
                
                // Heatmap with kernel density estimation
                const heatmapTrace = {
                    x: df.map(d => d.x),
                    y: df.map(d => d.y),
                    z: df.map(d => d.duration),
                    type: 'histogram2dcontour',
                    colorscale: 'Viridis',
                    showscale: true,
                    contours: {
                        coloring: 'heatmap'
                    }
                };

                const heatmapLayout = {
                    ...chartLayoutSettings,
                    title: 'Gaze Density Heatmap',
                    xaxis: { title: 'X Coordinate' },
                    yaxis: { title: 'Y Coordinate', autorange: 'reversed' }
                };

                Plotly.newPlot('heatmap', [heatmapTrace], heatmapLayout);
                
                document.getElementById('visualizations').style.display = 'block';
                logger.success('All visualizations created successfully');
            } catch (error) {
                logger.error(`Error creating visualizations: ${error.message}`);
                console.error('Visualization error:', error);
            }
        }

        // Helper functions
        function mean(arr) {
            if (!arr || arr.length === 0) return 0;
            const validValues = arr.filter(v => !isNaN(v) && isFinite(v));
            if (validValues.length === 0) return 0;
            return validValues.reduce((a,b) => a + b, 0) / validValues.length;
        }

        function median(arr) {
            if (!arr || arr.length === 0) return 0;
            const validValues = arr.filter(v => !isNaN(v) && isFinite(v));
            if (validValues.length === 0) return 0;
            
            const sorted = [...validValues].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            
            return sorted.length % 2 === 0
                ? (sorted[mid-1] + sorted[mid]) / 2
                : sorted[mid];
        }

        function std(arr) {
            if (!arr || arr.length === 0) return 0;
            const validValues = arr.filter(v => !isNaN(v) && isFinite(v));
            if (validValues.length === 0) return 0;
            
            const m = mean(validValues);
            return Math.sqrt(validValues.reduce((a,b) => a + Math.pow(b - m, 2), 0) / validValues.length);
        }

        function calculatePolygonArea(points) {
            try {
                if (!points || points.length < 3) return 0;
                
                let area = 0;
                for (let i = 0; i < points.length; i++) {
                    const j = (i + 1) % points.length;
                    area += points[i][0] * points[j][1];
                    area -= points[j][0] * points[i][1];
                }
                return Math.abs(area / 2);
            } catch (error) {
                logger.warning(`Error calculating polygon area: ${error.message}`);
                return 0;
            }
        }
    </script>
</body>
</html>
