<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaze Data Analysis</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hull.js/1.0.2/hull.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            line-height: 1.6;
        }
        .section { 
            margin: 20px 0; 
            padding: 15px; 
            border: 1px solid #ddd; 
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .chart { 
            width: 100%; 
            height: 400px; 
            margin: 15px 0;
            border: 1px solid #eee;
            border-radius: 5px;
        }
        input, button { 
            margin: 10px 5px 10px 0; 
            padding: 8px 12px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        #logger {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
        }
        .log-info { color: #333; }
        .log-success { color: #4CAF50; }
        .log-warning { color: #ff9800; }
        .log-error { color: #f44336; }
        .loading {
            display: none;
            margin-left: 10px;
            animation: spin 2s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>Gaze Data Analysis Tool</h1>
    
    <div class="section">
        <h3>Data Input</h3>
        <p>Upload a CSV file with eye-tracking data. The file should contain columns for timestamp, x, and y coordinates.</p>
        <input type="file" id="csvFile" accept=".csv">
        <button id="processButton" onclick="processData()">Process Data</button>
        <span id="loading" class="loading">‚ü≥</span>
    </div>

    <div id="logger" class="section">
        <div class="log-info">System ready. Upload a CSV file to begin analysis.</div>
    </div>

    <div id="output" class="section" style="display:none;">
        <h3>Analysis Results</h3>
        <div id="resultsContent"></div>
    </div>
    
    <div id="visualizations" class="section" style="display:none;">
        <h3>Visualizations</h3>
        <div id="gazePath" class="chart"></div>
        <div id="velocityChart" class="chart"></div>
        <div id="fixationMap" class="chart"></div>
    </div>

    <script>
        // Global variables
        let logger;

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            logger = new Logger('logger');
            logger.info('Gaze Data Analysis Tool initialized');
            logger.info('Please upload a CSV file to begin');
        });

        // Logging utility class
        class Logger {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                if (!this.element) {
                    console.error('Logger element not found:', elementId);
                    return;
                }
            }

            log(message, level = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-${level}`;
                logEntry.innerHTML = `[${timestamp}] ${message}`;
                this.element.appendChild(logEntry);
                this.element.scrollTop = this.element.scrollHeight;
                console.log(`[${level.toUpperCase()}] ${message}`);
            }

            info(message) { this.log(message, 'info'); }
            success(message) { this.log(message, 'success'); }
            warning(message) { this.log(message, 'warning'); }
            error(message) { this.log(message, 'error'); }
            
            clear() {
                this.element.innerHTML = '';
            }
        }

        async function processData() {
            try {
                // Show loading indicator
                document.getElementById('loading').style.display = 'inline-block';
                document.getElementById('processButton').disabled = true;
                
                logger.info('Starting data processing...');
                
                const file = document.getElementById('csvFile').files[0];
                if (!file) {
                    logger.error('No file selected. Please choose a CSV file.');
                    return;
                }
                
                logger.info(`Processing file: ${file.name} (${formatFileSize(file.size)})`);
                
                // Read the file content
                const text = await file.text();
                logger.info(`File loaded successfully. Parsing CSV data...`);
                
                // Parse CSV
                const data = parseCSV(text);
                logger.info(`CSV parsed successfully. Found ${data.length} data points.`);
                
                if (data.length === 0) {
                    logger.error('No data found in CSV file or parsing failed.');
                    return;
                }

                // Check for required columns
                const requiredColumns = ['timestamp', 'x', 'y'];
                const missingColumns = requiredColumns.filter(col => !(col in data[0]));
                
                if (missingColumns.length > 0) {
                    logger.error(`Missing required columns: ${missingColumns.join(', ')}`);
                    logger.info(`Available columns: ${Object.keys(data[0]).join(', ')}`);
                    return;
                }
                
                // Preprocessing
                logger.info('Preprocessing data...');
                let df = preprocessData(data);
                logger.success(`Preprocessing complete. Data normalized and derivatives calculated.`);
                
                // Basic Metrics
                logger.info('Calculating basic statistics...');
                const basicStats = calculateBasicStats(df);
                logger.success('Basic statistics calculated successfully.');
                
                // Fixation/Saccade Detection
                logger.info('Detecting fixations and saccades...');
                const { fixations, saccades } = detectFixationsSaccades(df);
                logger.success(`Detection complete. Found ${fixations.length} fixations and ${saccades.length} saccades.`);
                
                // Advanced Metrics
                logger.info('Calculating advanced metrics...');
                const advancedMetrics = calculateAdvancedMetrics(df, fixations, basicStats);
                logger.success('Advanced metrics calculated successfully.');
                
                // Display Results
                logger.info('Displaying results...');
                displayResults(basicStats, fixations, saccades, advancedMetrics);
                
                // Create Visualizations
                logger.info('Generating visualizations...');
                createVisualizations(df, fixations);
                logger.success('Analysis complete!');
                
                // Show output and visualization sections
                document.getElementById('output').style.display = 'block';
                document.getElementById('visualizations').style.display = 'block';
            } catch (error) {
                logger.error(`Error during data processing: ${error.message}`);
                console.error('Processing error:', error);
            } finally {
                // Hide loading indicator
                document.getElementById('loading').style.display = 'none';
                document.getElementById('processButton').disabled = false;
            }
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }

        function parseCSV(text) {
            try {
                // Split by lines and filter out empty lines
                const rows = text.split('\n').filter(row => row.trim());
                
                if (rows.length < 2) {
                    logger.error('CSV file has insufficient data (less than 2 rows)');
                    return [];
                }
                
                // Get headers from the first row
                const headers = rows[0].split(',').map(h => h.trim());
                logger.info(`CSV headers: ${headers.join(', ')}`);
                
                // Parse data rows
                const data = [];
                for (let i = 1; i < rows.length; i++) {
                    const values = rows[i].split(',');
                    
                    // Skip rows with incorrect number of columns
                    if (values.length !== headers.length) {
                        logger.warning(`Skipping row ${i+1}: expected ${headers.length} columns, got ${values.length}`);
                        continue;
                    }
                    
                    const rowObj = {};
                    headers.forEach((header, j) => {
                        const value = values[j].trim();
                        rowObj[header] = isNaN(parseFloat(value)) ? value : parseFloat(value);
                    });
                    data.push(rowObj);
                }
                
                logger.info(`Parsed ${data.length} valid data rows`);
                return data;
            } catch (error) {
                logger.error(`CSV parsing error: ${error.message}`);
                return [];
            }
        }

        function preprocessData(data) {
            try {
                logger.info('Sorting data by timestamp...');
                // Sort by timestamp
                data.sort((a, b) => a.timestamp - b.timestamp);
                
                logger.info('Handling missing values...');
                // Forward-fill missing values
                let prev = {};
                data.forEach((d, i) => {
                    Object.keys(d).forEach(k => {
                        if (isNaN(d[k])) {
                            d[k] = prev[k] || 0;
                            logger.warning(`Row ${i}: Missing value in '${k}' column, filled with ${d[k]}`);
                        }
                    });
                    prev = {...d};
                });

                logger.info('Calculating derivatives and velocity...');
                // Calculate derivatives
                data.forEach((d, i) => {
                    // Time difference in milliseconds
                    d.dt = i > 0 ? d.timestamp - data[i-1].timestamp : 
                           (data.length > 1 ? data[1].timestamp - data[0].timestamp : 0);
                    
                    // Position differences
                    d.dx = i > 0 ? d.x - data[i-1].x : 0;
                    d.dy = i > 0 ? d.y - data[i-1].y : 0;
                    
                    // Distance and velocity
                    d.distance = Math.sqrt(d.dx**2 + d.dy**2);
                    d.velocity = d.dt > 0 ? (d.distance / (d.dt / 1000)) : 0;
                });
                
                // Log data range information
                const firstTimestamp = data[0].timestamp;
                const lastTimestamp = data[data.length-1].timestamp;
                const duration = (lastTimestamp - firstTimestamp) / 1000;
                
                logger.info(`Data spans ${duration.toFixed(2)} seconds (${data.length} points)`);
                logger.info(`X-range: ${Math.min(...data.map(d => d.x)).toFixed(1)} to ${Math.max(...data.map(d => d.x)).toFixed(1)}`);
                logger.info(`Y-range: ${Math.min(...data.map(d => d.y)).toFixed(1)} to ${Math.max(...data.map(d => d.y)).toFixed(1)}`);
                
                return data;
            } catch (error) {
                logger.error(`Error during preprocessing: ${error.message}`);
                return data; // Return original data on error
            }
        }

        function calculateBasicStats(df) {
            try {
                const x = df.map(d => d.x);
                const y = df.map(d => d.y);
                const velocities = df.map(d => d.velocity).filter(v => !isNaN(v) && isFinite(v));
                const distances = df.map(d => d.distance).filter(d => !isNaN(d) && isFinite(d));
                
                const duration = (df[df.length-1].timestamp - df[0].timestamp) / 1000;
                const totalDistance = distances.reduce((sum, d) => sum + d, 0);
                
                const stats = {
                    duration_sec: duration,
                    total_distance: totalDistance,
                    average_distance_per_sec: totalDistance / duration,
                    velocity_mean: mean(velocities),
                    velocity_median: median(velocities),
                    velocity_std: std(velocities),
                    velocity_max: Math.max(...velocities),
                    x_mean: mean(x),
                    y_mean: mean(y),
                    x_std: std(x),
                    y_std: std(y),
                    total_points: df.length,
                    sampling_rate: df.length / duration
                };
                
                // Log key statistics
                logger.info(`Duration: ${stats.duration_sec.toFixed(2)} seconds`);
                logger.info(`Total distance: ${stats.total_distance.toFixed(2)} pixels`);
                logger.info(`Mean velocity: ${stats.velocity_mean.toFixed(2)} pixels/sec`);
                logger.info(`Sampling rate: ${stats.sampling_rate.toFixed(2)} Hz`);
                
                return stats;
            } catch (error) {
                logger.error(`Error calculating basic statistics: ${error.message}`);
                return {
                    duration_sec: 0,
                    total_distance: 0,
                    velocity_mean: 0,
                    velocity_max: 0,
                    x_mean: 0,
                    y_mean: 0,
                    x_std: 0,
                    y_std: 0,
                    total_points: 0,
                    sampling_rate: 0
                };
            }
        }

        function detectFixationsSaccades(df) {
            try {
                // Parameters for detection algorithm
                const VELOCITY_THRESHOLD = 50; // pixels/second
                const MIN_DURATION = 100; // milliseconds
                const MIN_POINTS = 3; // minimum points to consider a fixation
                
                logger.info(`Using velocity threshold of ${VELOCITY_THRESHOLD} px/sec for fixation detection`);
                logger.info(`Minimum fixation duration: ${MIN_DURATION} ms`);
                
                let fixations = [];
                let saccades = [];
                let currentFix = null;

                // Detect potential fixations based on velocity
                df.forEach((d, i) => {
                    if (d.velocity < VELOCITY_THRESHOLD) {
                        // Start a new fixation or add to existing
                        if (!currentFix) {
                            currentFix = {
                                start: i,
                                startTime: d.timestamp,
                                points: [],
                                durations: [],
                                x_values: [],
                                y_values: []
                            };
                        }
                        currentFix.points.push([d.x, d.y]);
                        currentFix.durations.push(d.dt);
                        currentFix.x_values.push(d.x);
                        currentFix.y_values.push(d.y);
                    } else if (currentFix) {
                        // End current fixation
                        const duration = currentFix.durations.reduce((a,b) => a + b, 0);
                        if (duration >= MIN_DURATION && currentFix.points.length >= MIN_POINTS) {
                            // Calculate centroid of fixation points
                            const x_sum = currentFix.x_values.reduce((a,b) => a + b, 0);
                            const y_sum = currentFix.y_values.reduce((a,b) => a + b, 0);
                            const count = currentFix.points.length;
                            
                            fixations.push({
                                ...currentFix,
                                centroid: [x_sum/count, y_sum/count],
                                x_centroid: x_sum/count,
                                y_centroid: y_sum/count,
                                duration: duration,
                                end: i-1,
                                endTime: df[i-1].timestamp,
                                dispersion: calculateDispersion(currentFix.x_values, currentFix.y_values)
                            });
                        }
                        currentFix = null;
                    }
                });

                // Add the last fixation if it exists
                if (currentFix) {
                    const duration = currentFix.durations.reduce((a,b) => a + b, 0);
                    if (duration >= MIN_DURATION && currentFix.points.length >= MIN_POINTS) {
                        const x_sum = currentFix.x_values.reduce((a,b) => a + b, 0);
                        const y_sum = currentFix.y_values.reduce((a,b) => a + b, 0);
                        const count = currentFix.points.length;
                        
                        fixations.push({
                            ...currentFix,
                            centroid: [x_sum/count, y_sum/count],
                            x_centroid: x_sum/count,
                            y_centroid: y_sum/count,
                            duration: duration,
                            end: df.length-1,
                            endTime: df[df.length-1].timestamp,
                            dispersion: calculateDispersion(currentFix.x_values, currentFix.y_values)
                        });
                    }
                }

                logger.info(`Detected ${fixations.length} fixations`);
                
                // Calculate saccades between fixations
                for (let i = 1; i < fixations.length; i++) {
                    const prev = fixations[i-1];
                    const curr = fixations[i];
                    
                    const saccadeDuration = curr.startTime - prev.endTime;
                    const amplitude = Math.hypot(
                        curr.x_centroid - prev.x_centroid,
                        curr.y_centroid - prev.y_centroid
                    );
                    
                    const peakVelocity = findPeakVelocity(df, prev.end, curr.start);
                    
                    saccades.push({
                        startTime: prev.endTime,
                        endTime: curr.startTime,
                        duration: saccadeDuration,
                        amplitude: amplitude,
                        peakVelocity: peakVelocity,
                        avgVelocity: amplitude / (saccadeDuration / 1000),
                        startIndex: prev.end,
                        endIndex: curr.start,
                        startPoint: [prev.x_centroid, prev.y_centroid],
                        endPoint: [curr.x_centroid, curr.y_centroid]
                    });
                }

                logger.info(`Detected ${saccades.length} saccades`);
                
                return { fixations, saccades };
            } catch (error) {
                logger.error(`Error detecting fixations and saccades: ${error.message}`);
                return { fixations: [], saccades: [] };
            }
        }
        
        function findPeakVelocity(df, startIndex, endIndex) {
            try {
                let peakVelocity = 0;
                for (let i = startIndex; i <= endIndex; i++) {
                    if (df[i].velocity > peakVelocity) {
                        peakVelocity = df[i].velocity;
                    }
                }
                return peakVelocity;
            } catch (error) {
                logger.warning(`Error finding peak velocity: ${error.message}`);
                return 0;
            }
        }
        
        function calculateDispersion(x_values, y_values) {
            try {
                const x_min = Math.min(...x_values);
                const x_max = Math.max(...x_values);
                const y_min = Math.min(...y_values);
                const y_max = Math.max(...y_values);
                
                return Math.max(x_max - x_min, y_max - y_min);
            } catch (error) {
                logger.warning(`Error calculating dispersion: ${error.message}`);
                return 0;
            }
        }

        function calculateAdvancedMetrics(df, fixations, stats) {
            try {
                // Path efficiency (straight-line distance / total distance)
                const start = [df[0].x, df[0].y];
                const end = [df[df.length-1].x, df[df.length-1].y];
                const straightLineDistance = Math.hypot(end[0]-start[0], end[1]-start[1]);
                const pathEfficiency = straightLineDistance / stats.total_distance;
                
                logger.info(`Path efficiency: ${pathEfficiency.toFixed(4)} (straight: ${straightLineDistance.toFixed(2)} px)`);
                
                // Convex hull area calculation
                let hullArea = 0;
                let fixationDwellTime = 0;
                let meanFixationDuration = 0;
                
                try {
                    const points = df.map(d => [d.x, d.y]);
                    // Skip convex hull if very few points
                    if (points.length > 3) {
                        const hullPoints = window.hull(points, Infinity);
                        if (hullPoints && hullPoints.length > 2) {
                            hullArea = calculatePolygonArea(hullPoints);
                            logger.info(`Convex hull calculated with ${hullPoints.length} points`);
                        } else {
                            logger.warning('Convex hull calculation produced invalid result');
                        }
                    } else {
                        logger.warning('Too few points for convex hull calculation');
                    }
                } catch (hullError) {
                    logger.error(`Convex hull error: ${hullError.message}`);
                }
                
                // Fixation metrics
                if (fixations.length > 0) {
                    fixationDwellTime = fixations.reduce((sum, f) => sum + f.duration, 0) / 1000; // in seconds
                    meanFixationDuration = fixationDwellTime * 1000 / fixations.length; // in ms
                    
                    logger.info(`Total fixation dwell time: ${fixationDwellTime.toFixed(2)} sec (${(fixationDwellTime/stats.duration_sec*100).toFixed(1)}% of total)`);
                    logger.info(`Mean fixation duration: ${meanFixationDuration.toFixed(2)} ms`);
                }
                
                // Scanpath metrics
                const scanpathLength = stats.total_distance;
                const scanpathDuration = stats.duration_sec;
                const scanpathVelocity = scanpathLength / scanpathDuration;
                
                return {
                    path_efficiency: pathEfficiency,
                    convex_hull_area: hullArea,
                    fixation_count: fixations.length,
                    fixation_frequency: fixations.length / scanpathDuration,
                    fixation_dwell_time: fixationDwellTime,
                    fixation_dwell_time_percent: (fixationDwellTime / scanpathDuration) * 100,
                    mean_fixation_duration: meanFixationDuration,
                    scanpath_length: scanpathLength,
                    scanpath_duration: scanpathDuration,
                    scanpath_velocity: scanpathVelocity
                };
            } catch (error) {
                logger.error(`Error calculating advanced metrics: ${error.message}`);
                return {
                    path_efficiency: 0,
                    convex_hull_area: 0,
                    fixation_count: 0,
                    fixation_frequency: 0,
                    fixation_dwell_time: 0,
                    fixation_dwell_time_percent: 0,
                    mean_fixation_duration: 0,
                    scanpath_length: 0,
                    scanpath_duration: 0,
                    scanpath_velocity: 0
                };
            }
        }

        function displayResults(basic, fixations, saccades, advanced) {
            try {
                let html = `
                    <h4>Basic Statistics</h4>
                    <ul>
                        <li>Duration: ${basic.duration_sec.toFixed(2)} seconds</li>
                        <li>Total points: ${basic.total_points}</li>
                        <li>Sampling rate: ${basic.sampling_rate.toFixed(2)} Hz</li>
                        <li>Total distance: ${basic.total_distance.toFixed(2)} pixels</li>
                        <li>Mean velocity: ${basic.velocity_mean.toFixed(2)} pixels/second</li>
                        <li>Max velocity: ${basic.velocity_max.toFixed(2)} pixels/second</li>
                    </ul>

                    <h4>Fixation & Saccade Analysis</h4>
                    <ul>
                        <li>Fixations detected: ${fixations.length}</li>
                        <li>Mean fixation duration: ${advanced.mean_fixation_duration.toFixed(2)} ms</li>
                        <li>Fixation frequency: ${advanced.fixation_frequency.toFixed(2)} per second</li>
                        <li>Fixation dwell time: ${advanced.fixation_dwell_time.toFixed(2)} seconds (${advanced.fixation_dwell_time_percent.toFixed(1)}% of total)</li>
                        <li>Saccades detected: ${saccades.length}</li>
                        ${saccades.length > 0 ? `<li>Mean saccade amplitude: ${mean(saccades.map(s => s.amplitude)).toFixed(2)} pixels</li>` : ''}
                        ${saccades.length > 0 ? `<li>Mean saccade duration: ${mean(saccades.map(s => s.duration)).toFixed(2)} ms</li>` : ''}
                    </ul>

                    <h4>Advanced Metrics</h4>
                    <ul>
                        <li>Path efficiency: ${advanced.path_efficiency.toFixed(4)}</li>
                        <li>Convex hull area: ${advanced.convex_hull_area.toFixed(2)} square pixels</li>
                        <li>Scanpath length: ${advanced.scanpath_length.toFixed(2)} pixels</li>
                        <li>Scanpath velocity: ${advanced.scanpath_velocity.toFixed(2)} pixels/second</li>
                    </ul>
                `;
                
                document.getElementById('resultsContent').innerHTML = html;
                document.getElementById('output').style.display = 'block';
                
                logger.success('Results displayed successfully');
            } catch (error) {
                logger.error(`Error displaying results: ${error.message}`);
            }
        }

        function createVisualizations(df, fixations) {
            try {
                // 1. Gaze path visualization
                const pathTrace = {
                    x: df.map(d => d.x),
                    y: df.map(d => d.y),
                    mode: 'lines',
                    line: {
                        color: 'rgba(0, 128, 255, 0.7)',
                        width: 2
                    },
                    name: 'Gaze Path',
                    type: 'scatter'
                };
                
                // Create layout with reversed y-axis (typical for screen coordinates)
                const gazePathLayout = {
                    title: 'Gaze Path',
                    xaxis: { title: 'X Coordinate' },
                    yaxis: { 
                        title: 'Y Coordinate',
                        autorange: 'reversed' // Reverse Y axis for screen coordinates
                    },
                    hovermode: 'closest',
                    margin: { t: 50, b: 50, l: 50, r: 50 }
                };
                
                Plotly.newPlot('gazePath', [pathTrace], gazePathLayout, { responsive: true });
                logger.info('Gaze path visualization created');
                
                // 2. Velocity profile
                const velocityTrace = {
                    x: df.map((d, i) => (d.timestamp - df[0].timestamp) / 1000), // Convert to seconds from start
                    y: df.map(d => d.velocity),
                    mode: 'lines',
                    line: { color: 'rgba(255, 0, 0, 0.7)' },
                    name: 'Velocity',
                    type: 'scatter'
                };
                
                const velocityLayout = {
                    title: 'Velocity Profile',
                    xaxis: { title: 'Time (seconds)' },
                    yaxis: { title: 'Velocity (pixels/second)' },
                    margin: { t: 50, b: 50, l: 50, r: 50 }
                };
                
                Plotly.newPlot('velocityChart', [velocityTrace], velocityLayout, { responsive: true });
                logger.info('Velocity profile visualization created');
                
                // 3. Fixation map
                if (fixations.length > 0) {
                    // Add detected fixations to gaze path plot
                    const fixationTrace = {
                        x: fixations.map(f => f.x_centroid),
                        y: fixations.map(f => f.y_centroid),
                        mode: 'markers',
                        marker: {
                            size: fixations.map(f => Math.sqrt(f.duration) / 5),
                            color: 'rgba(255, 165, 0, 0.8)',
                            line: { width: 1, color: 'black' }
                        },
                        text: fixations.map((f, i) => `Fixation ${i+1}<br>Duration: ${f.duration.toFixed(0)} ms<br>Dispersion: ${f.dispersion.toFixed(1)} px`),
                        name: 'Fixations',
                        type: 'scatter',
                        hoverinfo: 'text'
                    };
                    
                    const fixationMap = {
                        x: fixations.map(f => f.x_centroid),
                        y: fixations.map(f => f.y_centroid),
                        mode: 'markers+text',
                        marker: {
                            size: fixations.map(f => Math.min(Math.max(f.duration / 30, 10), 40)),
                            color: fixations.map((f, i) => `hsl(${(i * 360 / fixations.length) % 360}, 70%, 50%)`),
                            opacity: 0.7,
                            line: { width: 1, color: 'black' }
                        },
                        text: fixations.map((f, i) => `${i+1}`),
                        textposition: 'middle center',
                        textfont: {
                            size: 10,
                            color: 'white'
                        },
                        name: 'Fixations',
                        type: 'scatter',
                        hoverinfo: 'text',
                        hovertext: fixations.map((f, i) => 
                            `Fixation ${i+1}<br>Duration: ${f.duration.toFixed(0)} ms<br>` + 
                            `Position: (${f.x_centroid.toFixed(1)}, ${f.y_centroid.toFixed(1)})<br>` +
                            `Dispersion: ${f.dispersion.toFixed(1)} px`)
                    };
                    
                    const fixationConnections = {
                        x: fixations.flatMap((f, i) => i > 0 ? [fixations[i-1].x_centroid, f.x_centroid, null] : []),
                        y: fixations.flatMap((f, i) => i > 0 ? [fixations[i-1].y_centroid, f.y_centroid, null] : []),
                        mode: 'lines',
                        line: {
                            color: 'rgba(100, 100, 100, 0.5)',
                            width: 1,
                            dash: 'dot'
                        },
                        name: 'Scan Path',
                        type: 'scatter'
                    };
                    
                    const fixationMapLayout = {
                        title: 'Fixation Map',
                        xaxis: { title: 'X Coordinate' },
                        yaxis: { 
                            title: 'Y Coordinate',
                            autorange: 'reversed'
                        },
                        showlegend: false,
                        hovermode: 'closest',
                        margin: { t: 50, b: 50, l: 50, r: 50 }
                    };
                    
                    Plotly.newPlot('fixationMap', [fixationMap, fixationConnections], fixationMapLayout, { responsive: true });
                    logger.info('Fixation map created');
                    
                    // Add fixation trace to gaze path
                    Plotly.addTraces('gazePath', [fixationTrace]);
                } else {
                    document.getElementById('fixationMap').innerHTML = '<div style="text-align:center;padding:20px;">No fixations detected</div>';
                    logger.warning('No fixations to display on fixation map');
                }
                
                document.getElementById('visualizations').style.display = 'block';
                logger.success('All visualizations created successfully');
            } catch (error) {
                logger.error(`Error creating visualizations: ${error.message}`);
                console.error('Visualization error:', error);
            }
        }

        // Helper functions
        function mean(arr) {
            if (!arr || arr.length === 0) return 0;
            const validValues = arr.filter(v => !isNaN(v) && isFinite(v));
            if (validValues.length === 0) return 0;
            return validValues.reduce((a,b) => a + b, 0) / validValues.length;
        }

        function median(arr) {
            if (!arr || arr.length === 0) return 0;
            const validValues = arr.filter(v => !isNaN(v) && isFinite(v));
            if (validValues.length === 0) return 0;
            
            const sorted = [...validValues].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            
            return sorted.length % 2 === 0
                ? (sorted[mid-1] + sorted[mid]) / 2
                : sorted[mid];
        }

        function std(arr) {
            if (!arr || arr.length === 0) return 0;
            const validValues = arr.filter(v => !isNaN(v) && isFinite(v));
            if (validValues.length === 0) return 0;
            
            const m = mean(validValues);
            return Math.sqrt(validValues.reduce((a,b) => a + Math.pow(b - m, 2), 0) / validValues.length);
        }

        function calculatePolygonArea(points) {
            try {
                if (!points || points.length < 3) return 0;
                
                let area = 0;
                for (let i = 0; i < points.length; i++) {
                    const j = (i + 1) % points.length;
                    area += points[i][0] * points[j][1];
                    area -= points[j][0] * points[i][1];
                }
                return Math.abs(area / 2);
            } catch (error) {
                logger.warning(`Error calculating polygon area: ${error.message}`);
                return 0;
            }
        }
    </script>
</body>
</html>
